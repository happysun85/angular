<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Title</title>
<script src="angular.js"></script>
<script>
var app = angular.module('myapp', []);
app.directive('myDir', function() {
  return {
    //模板以哪种方式替换到指定位置  默认值 AE   A:属性； C:class； M:注释； E：元素
    restrict: 'AE',
    /*
     scope默认有一下3中方式
     1. 不填默认为false   作用域在父级里，也就是可以用父级里的东西
     2. true             继承父级，并且可以有自己的作用域。
     3. {}为对象；  表示要创建一个独立的作用域，不会继承父级。
     4. 第四种是第三种方式的强化，即虽然我的作用域与外界隔离了，
     但有一些参数（数值，属性，方法）还是想从外界获得。那么该如何获得呢，
     分别是 ‘=’、 ‘@’、 ‘&’， 他们的作用分别是：
     @： 通过属性值进行绑定，但是单向的，即外界控制器可以把值传进来供内部使用，
     但内部对这个属性值进行修改时不会影响到外部的；
     =：效果是双向绑定
     &：调用父级的方法
     */
    scope: {
      local: '=localname',   //不允许大写。。。
      fun: '&parentfunc'
    },
    template: function() {
      return angular.element(document.querySelector('#scopeTemplate')).html();
    },
    link: function(scope, ele, attrs) {
      //这里应该就是默认读进来后要做的一些操作而已

      ele[0].addEventListener('click',function(){
        alert('哎哟，成功了');
      })
      console.log('上来就会走？')
    }
  }
});

app.controller('myctr', function($scope) {
  $scope.data = {name: 'sunheng'};
  $scope.city = 'china';
  $scope.func = function(name) {
    return name + ' from ' + $scope.city;
  }
})
</script>

<script type="text/ng-template" id="scopeTemplate">
<div class="panel-body">
  <!--
   这种调用父级函数，貌似都要预设好，这边直接调用。不能在这加参数
   -->
  {{fun()}}<br>
  {{local}}
</div>
</script>
</head>
<body ng-app="myapp" ng-controller="myctr">
<my-dir parentfunc="func(data.name)" localname="data.name"></my-dir>
</body>
</html>
